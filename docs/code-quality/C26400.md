---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 05a33f078a77260a84573d99eaeabb9ca5bcccaf
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261506"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Bu denetim, ı 'yi zorlamaya yardımcı olur *. 11: hiçbir şekilde sahipliği bir ham işaretçi (t\*) tarafından hiçbir şekilde aktarılmaz* *. 3: bir ham işaretçi (t\*) sahip değildir.* Özellikle, sonucunu ham işaretçi türünde bir değişkende kaydeden işleç `new` çağrısıyla ilgili olarak uyarır. Ayrıca, sonuçları ham işaretçilere atandığında `gsl::owner<T>` döndüren işlevlere yapılan çağrılar üzerinde de sizi uyarır. Buradaki fikir, bellek kaynaklarının sahipliğini açık bir şekilde sağlamalısınız. Daha fazla bilgi için bkz. [ C++ temel yönergeler](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Bunu gidermenin en kolay yolu, kaynak değişken bildiriminde hemen atanırsa `auto` bildirimi kullanmaktır. Bu mümkün değilse, `gsl::owner<T>`türünü kullanmanızı öneririz. Herhangi bir ayırmanın sonucunun örtük olarak bir sahip işaretçisi olduğunu varsaydığımızda işleç `new` ile başlatılan `auto` bildirimleri "Owners" olur. Bu varsayım `auto` değişkenine aktarılcağız ve `owner<T>`olarak değerlendirilir.

Bu denetim, `owner<T>`döndüren bir işleve yapılan çağrıyı işaret ediyor, bu, koddaki meşru bir hata göstergesi olabilir. Temel olarak, kodun açık bir sahiplik kavramı (ve belki de kaynağın kendisi) olduğu bir yere işaret eder.

## <a name="remarks"></a>Açıklamalar

Bu kural şu anda yalnızca yerel değişkenleri denetliyor. Ayırma bir biçimsel parametreye, genel değişkene, sınıf üyesine ve bu şekilde atanmışsa, bayrak uygulanmaz. Bu senaryoların uygun kapsamı, gelecekteki çalışmanın bir parçasıdır.

## <a name="example-1-simple-allocation"></a>Örnek 1: basit ayırma

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Örnek 2: basit ayırma (GSL:: Owner\<T > ile düzeltildi)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
